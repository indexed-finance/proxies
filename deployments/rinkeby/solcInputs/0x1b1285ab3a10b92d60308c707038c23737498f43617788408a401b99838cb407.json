{
  "language": "Solidity",
  "sources": {
    "contracts/DelegateCallProxyManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\nimport { Create2 } from \"@openzeppelin/contracts/utils/Create2.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"./ManyToOneImplementationHolder.sol\";\nimport { DelegateCallProxyManyToOne } from \"./DelegateCallProxyManyToOne.sol\";\nimport { DelegateCallProxyOneToOne } from \"./DelegateCallProxyOneToOne.sol\";\n\nimport \"./Owned.sol\";\nimport { SaltyLib as Salty } from \"./SaltyLib.sol\";\n\n\n/**\n * @dev Contract that manages deployment and upgrades of delegatecall proxies.\n *\n * An implementation identifier can be created on the proxy manager which is\n * used to specify the logic address for a particular contract type, and to\n * upgrade the implementation as needed.\n *\n * A one-to-one proxy is a single proxy contract with an upgradeable implementation\n * address.\n *\n * A many-to-one proxy is a single upgradeable implementation address that may be\n * used by many proxy contracts.\n */\ncontract DelegateCallProxyManager is Owned {\n/* ---  Constants  --- */\n  bytes32 internal constant ONE_TO_ONE_CODEHASH\n  = keccak256(type(DelegateCallProxyOneToOne).creationCode);\n\n  bytes32 internal constant MANY_TO_ONE_CODEHASH\n  = keccak256(type(DelegateCallProxyManyToOne).creationCode);\n\n  bytes32 internal constant IMPLEMENTATION_HOLDER_CODEHASH\n  = keccak256(type(ManyToOneImplementationHolder).creationCode);\n\n/* ---  Events  --- */\n\n  event DeploymentApprovalGranted(address deployer);\n  event DeploymentApprovalRevoked(address deployer);\n\n  event ManyToOne_ImplementationCreated(\n    bytes32 implementationID,\n    address implementationAddress\n  );\n\n  event ManyToOne_ImplementationUpdated(\n    bytes32 implementationID,\n    address implementationAddress\n  );\n\n  event ManyToOne_ProxyDeployed(\n    bytes32 implementationID,\n    address proxyAddress\n  );\n\n  event OneToOne_ProxyDeployed(\n    address proxyAddress,\n    address implementationAddress\n  );\n\n  event OneToOne_ImplementationUpdated(\n    address proxyAddress,\n    address implementationAddress\n  );\n\n/* ---  Storage  --- */\n  // Addresses allowed to deploy many-to-one proxies.\n  mapping(address => bool) internal _approvedDeployers;\n\n  // Maps implementation holders to their implementation IDs.\n  mapping(bytes32 => address) internal _implementationHolders;\n\n  // Temporary value used in the many-to-one proxy constructor.\n  // The many-to-one proxy contract is deployed with create2 and\n  // uses static initialization code for simple address derivation,\n  // so it calls the proxy manager in the constructor to get this\n  // address in order to save it as an immutable in the bytecode.\n  address internal _implementationHolder;\n\n/* ---  Modifiers  --- */\n\n  modifier _admin_ {\n    require(\n      msg.sender == _owner || _approvedDeployers[msg.sender],\n      \"ERR_NOT_APPROVED\"\n    );\n    _;\n  }\n\n/* ---  Constructor  --- */\n\n  constructor() public Owned(msg.sender) {}\n\n/* ---  Controls  --- */\n\n  /**\n   * @dev Allows `deployer` to deploy many-to-one proxies.\n   */\n  function approveDeployer(address deployer) external _owner_ {\n    _approvedDeployers[deployer] = true;\n    emit DeploymentApprovalGranted(deployer);\n  }\n\n  /**\n   * @dev Prevents `deployer` from deploying many-to-one proxies.\n   */\n  function revokeDeployerApproval(address deployer) external _owner_ {\n    _approvedDeployers[deployer] = false;\n    emit DeploymentApprovalRevoked(deployer);\n  }\n\n/* ---  Implementation Management  --- */\n\n  /**\n   * @dev Creates a many-to-one proxy relationship.\n   *\n   * Deploys an implementation holder contract which stores the\n   * implementation address for many proxies. The implementation\n   * address can be updated on the holder to change the runtime\n   * code used by all its proxies.\n   *\n   * @param implementationID ID for the implementation, used to identify the\n   * proxies that use it. Also used as the salt in the create2 call when\n   * deploying the implementation holder contract.\n   * @param implementation Address with the runtime code the proxies\n   * should use.\n   */\n  function createManyToOneProxyRelationship(\n    bytes32 implementationID,\n    address implementation\n  )\n    external\n    _owner_\n  {\n    // Deploy the implementation holder contract with the implementation\n    // ID as the create2 salt.\n    address implementationHolder = Create2.deploy(\n      0,\n      implementationID,\n      type(ManyToOneImplementationHolder).creationCode\n    );\n\n    // Store the implementation holder address\n    _implementationHolders[implementationID] = implementationHolder;\n\n    // Sets the implementation address.\n    _setImplementation(implementationHolder, implementation);\n\n    emit ManyToOne_ImplementationCreated(\n      implementationID,\n      implementation\n    );\n  }\n\n  /**\n   * @dev Updates the implementation address for a many-to-one\n   * proxy relationship.\n   *\n   * @param implementationID Identifier for the implementation.\n   * @param implementation Address with the runtime code the proxies\n   * should use.\n   */\n  function setImplementationAddressManyToOne(\n    bytes32 implementationID,\n    address implementation\n  )\n    external\n    _owner_\n  {\n    // Read the implementation holder address from storage.\n    address implementationHolder = _implementationHolders[implementationID];\n\n    // Verify that the implementation exists.\n    require(implementationHolder != address(0), \"ERR_IMPLEMENTATION_ID\");\n\n    // Set the implementation address\n    _setImplementation(implementationHolder, implementation);\n\n    emit ManyToOne_ImplementationUpdated(\n      implementationID,\n      implementation\n    );\n  }\n\n  /**\n   * @dev Updates the implementation address for a one-to-one proxy.\n   *\n   * Note: This could work for many-to-one as well if the caller\n   * provides the implementation holder address in place of the\n   * proxy address, as they use the same access control and update\n   * mechanism.\n   *\n   * @param proxyAddress Address of the deployed proxy\n   * @param implementation Address with the runtime code for\n   * the proxy to use.\n   */\n  function setImplementationAddressOneToOne(\n    address proxyAddress,\n    address implementation\n  )\n    external\n    _owner_\n  {\n    // Set the implementation address\n    _setImplementation(proxyAddress, implementation);\n\n    emit OneToOne_ImplementationUpdated(proxyAddress, implementation);\n  }\n\n/* ---  Proxy Deployment  --- */\n\n  /**\n   * @dev Deploy a proxy contract with a one-to-one relationship\n   * with its implementation.\n   *\n   * The proxy will have its own implementation address which can\n   * be updated by the proxy manager.\n   *\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   * @param implementation Address of the contract with the runtime\n   * code that the proxy should use.\n   */\n  function deployProxyOneToOne(\n    bytes32 suppliedSalt,\n    address implementation\n  )\n    external\n    _owner_\n    returns(address proxyAddress)\n  {\n    // Derive the create2 salt from the deployment requester's address\n    // and the requester-supplied salt.\n    bytes32 salt = Salty.deriveOneToOneSalt(msg.sender, suppliedSalt);\n\n    // Deploy the proxy\n    proxyAddress = Create2.deploy(\n      0,\n      salt,\n      type(DelegateCallProxyOneToOne).creationCode\n    );\n\n    // Set the implementation address on the new proxy.\n    _setImplementation(proxyAddress, implementation);\n\n    emit OneToOne_ProxyDeployed(proxyAddress, implementation);\n  }\n\n  /**\n   * @dev Deploy a proxy with a many-to-one relationship with its implemenation.\n   *\n   * The proxy will call the implementation holder for every transaction to\n   * determine the address to use in calls.\n   *\n   * @param implementationID Identifier for the proxy's implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deployProxyManyToOne(bytes32 implementationID, bytes32 suppliedSalt)\n    external\n    _admin_\n    returns(address proxyAddress)\n  {\n    // Read the implementation holder address from storage.\n    address implementationHolder = _implementationHolders[implementationID];\n\n    // Verify that the implementation exists.\n    require(implementationHolder != address(0), \"ERR_IMPLEMENTATION_ID\");\n\n    // Derive the create2 salt from the deployment requester's address, the\n    // implementation ID and the requester-supplied salt.\n    bytes32 salt = Salty.deriveManyToOneSalt(\n      msg.sender,\n      implementationID,\n      suppliedSalt\n    );\n\n    // Set the implementation holder address in storage so the proxy\n    // constructor can query it.\n    _implementationHolder = implementationHolder;\n\n    // Deploy the proxy, which will query the implementation holder address\n    // and save it as an immutable in the contract bytecode.\n    proxyAddress = Create2.deploy(\n      0,\n      salt,\n      type(DelegateCallProxyManyToOne).creationCode\n    );\n\n    // Remove the address from temporary storage.\n    _implementationHolder = address(0);\n\n    emit ManyToOne_ProxyDeployed(\n      implementationID,\n      proxyAddress\n    );\n  }\n\n/* ---  Queries  --- */\n\n  function isApprovedDeployer(address deployer) external view returns (bool) {\n    return _approvedDeployers[deployer];\n  }\n\n  /**\n   * @dev Queries the temporary storage value `_implementationHolder`.\n   * This is used in the constructor of the many-to-one proxy contract\n   * so that the create2 address is static (adding constructor arguments\n   * would change the codehash) and the implementation holder can be\n   * stored as a constant.\n   */\n  function getImplementationHolder()\n    external\n    view\n    returns (address)\n  {\n    return _implementationHolder;\n  }\n\n  /**\n   * @dev Returns the address of the implementation holder contract\n   * for `implementationID`.\n   */\n  function getImplementationHolder(\n    bytes32 implementationID\n  )\n    external\n    view\n    returns (address)\n  {\n    return _implementationHolders[implementationID];\n  }\n\n  /**\n   * @dev Computes the create2 address for a one-to-one proxy requested\n   * by `originator` using `suppliedSalt`.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function computeProxyAddressOneToOne(\n    address originator,\n    bytes32 suppliedSalt\n  )\n    external\n    view\n    returns (address)\n  {\n    bytes32 salt = Salty.deriveOneToOneSalt(originator, suppliedSalt);\n    return Create2.computeAddress(salt, ONE_TO_ONE_CODEHASH);\n  }\n\n  /**\n   * @dev Computes the create2 address for a many-to-one proxy for the\n   * implementation `implementationID` requested by `originator` using\n   * `suppliedSalt`.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n  */\n  function computeProxyAddressManyToOne(\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  )\n    external\n    view\n    returns (address)\n  {\n\n    bytes32 salt = Salty.deriveManyToOneSalt(\n      originator,\n      implementationID,\n      suppliedSalt\n    );\n    return Create2.computeAddress(salt, MANY_TO_ONE_CODEHASH);\n  }\n\n  /**\n   * @dev Computes the create2 address of the implementation holder\n   * for `implementationID`.\n   *\n   * @param implementationID The identifier for the contract implementation.\n  */\n  function computeHolderAddressManyToOne(bytes32 implementationID)\n    public\n    view\n    returns (address)\n  {\n    return Create2.computeAddress(\n      implementationID,\n      IMPLEMENTATION_HOLDER_CODEHASH\n    );\n  }\n\n/* ---  Internal Functions  --- */\n\n  /**\n   * @dev Sets the implementation address for a one-to-one proxy or\n   * many-to-one implementation holder. Both use the same access\n   * control and update mechanism, which is the receipt of a call\n   * from the proxy manager with the abi-encoded implementation address\n   * as the only calldata.\n   *\n   * Note: Verifies that the implementation address is a contract.\n   *\n   * @param proxyOrHolder Address of the one-to-one proxy or\n   * many-to-one implementation holder contract.\n   * @param implementation Address of the contract with the runtime\n   * code that the proxy or proxies should use.\n   */\n  function _setImplementation(\n    address proxyOrHolder,\n    address implementation\n  ) internal {\n    // Verify that the implementation address is a contract.\n    require(Address.isContract(implementation), \"ERR_NOT_CONTRACT\");\n    // Set the implementation address on the contract.\n\n    // solium-disable-next-line security/no-low-level-calls\n    (bool success,) = proxyOrHolder.call(abi.encode(implementation));\n    require(success, \"ERR_SET_ADDRESS_REVERT\");\n  }\n}"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\n        bytes32 _data = keccak256(\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\n        );\n        return address(uint256(_data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/ManyToOneImplementationHolder.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Stores a single implementation address which is used by\n * many proxies.\n *\n * Inspired by the DharmaUpgradeBeacon from 0age\n * dharma-eng/dharma-smart-wallet/contracts/upgradeability/DharmaUpgradeBeacon.sol\n */\ncontract ManyToOneImplementationHolder {\n/* ---  Storage  --- */\n  address internal immutable _owner;\n  address internal _implementation;\n\n/* ---  Constructor  --- */\n  constructor() public {\n    _owner = msg.sender;\n  }\n\n  /**\n   * @dev Fallback function for the contract.\n   *\n   * Used by proxies to read the implementation address and used\n   * by the proxy manager to set the implementation address.\n   *\n   * If called by the owner, reads the implementation address from\n   * calldata (must be abi-encoded) and stores it to the first slot.\n   *\n   * Otherwise, returns the stored implementation address.\n   */\n  fallback() external payable {\n    if (msg.sender != _owner) {\n      assembly {\n        mstore(0, sload(0))\n        return(0, 32)\n      }\n    }\n    assembly { sstore(0, calldataload(0)) }\n  }\n}"
    },
    "contracts/DelegateCallProxyManyToOne.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\nimport { Proxy } from \"@openzeppelin/contracts/proxy/Proxy.sol\";\n\n\n/**\n * @dev Proxy contract which uses an implementation address shared with many\n * other proxies.\n *\n * An implementation holder contract stores the upgradeable logic address.\n * The proxy contract calls the implementation holder to execute each delegated\n * transaction.\n *\n * Note: This contract does not verify that the implementation\n * address is a valid delegation target. The manager must perform\n * this safety check before updating the implementation on the holder.\n */\ncontract DelegateCallProxyManyToOne is Proxy {\n/* ---  Constants  --- */\n\n  // Address that stores the implementation address.\n  address internal immutable _implementationHolder;\n\n/* ---  Constructor  --- */\n\n  constructor() public {\n    // Calls the sender rather than receiving the address in the constructor\n    // arguments so that the address is computable using create2.\n    _implementationHolder = ProxyDeployer(msg.sender).getImplementationHolder();\n  }\n\n/* ---  Internal Overrides  --- */\n\n  /**\n   * @dev Queries the implementation address from the implementation holder.\n   */\n  function _implementation() internal override view returns (address) {\n    // Queries the implementation address from the implementation holder.\n    (bool success, bytes memory data) = _implementationHolder.staticcall(\"\");\n    require(success, string(data));\n    address implementation = abi.decode((data), (address));\n    require(implementation != address(0), \"ERR_NULL_IMPLEMENTATION\");\n    return implementation;\n  }\n}\n\ninterface ProxyDeployer {\n  function getImplementationHolder() external view returns (address);\n}"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n * \n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n * \n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     * \n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal virtual view returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     * \n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () payable external {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive () payable external {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     * \n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n    }\n}\n"
    },
    "contracts/DelegateCallProxyOneToOne.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\nimport { Proxy } from \"@openzeppelin/contracts/proxy/Proxy.sol\";\n\n\n/**\n * @dev Upgradeable delegatecall proxy for a single contract.\n *\n * This proxy stores an implementation address which can be\n * upgraded by the proxy manager.\n *\n * The storage slot for the implementation address is:\n * `bytes32(uint256(keccak256(\"IMPLEMENTATION_ADDRESS\")) + 1)`\n * This slot must not be used by the implementation contract.\n *\n * To upgrade the proxy, the manager calls the proxy with the\n * abi encoded implementation address.\n *\n * Note: This contract does not verify that the implementation\n * address is a valid delegation target. The manager must perform\n * this safety check.\n */\ncontract DelegateCallProxyOneToOne is Proxy {\n/* ---  Constants  --- */\n  address internal immutable _owner;\n\n/* ---  Constructor  --- */\n  constructor() public {\n    _owner = msg.sender ;\n  }\n\n/* ---  Internal Overrides  --- */\n\n  /**\n   * @dev Reads the implementation address from storage.\n   */\n  function _implementation() internal override view returns (address) {\n    address implementation;\n    assembly {\n      implementation := sload(\n        // bytes32(uint256(keccak256(\"IMPLEMENTATION_ADDRESS\")) + 1)\n        0x913bd12b32b36f36cedaeb6e043912bceb97022755958701789d3108d33a045a\n      )\n    }\n    return implementation;\n  }\n\n  /**\n    * @dev Hook that is called before falling back to the implementation.\n    *\n    * Checks if the call is from the owner.\n    * If it is, reads the abi-encoded implementation address from calldata and stores\n    * it at the slot `bytes32(uint256(keccak256(\"IMPLEMENTATION_ADDRESS\")) + 1)`,\n    * then returns with no data.\n    * If it is not, continues execution with the fallback function.\n    */\n  function _beforeFallback() internal override {\n    if (msg.sender != _owner) {\n      super._beforeFallback();\n    } else {\n      assembly {\n        sstore(\n          // bytes32(uint256(keccak256(\"IMPLEMENTATION_ADDRESS\")) + 1)\n          0x913bd12b32b36f36cedaeb6e043912bceb97022755958701789d3108d33a045a,\n          calldataload(0)\n        )\n        return(0, 0)\n      }\n    }\n  }\n}\n"
    },
    "contracts/Owned.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\ncontract Owned {\n  event OwnerSet(address newOwner);\n\n  address internal _owner;\n\n  modifier _owner_ {\n    require(msg.sender == _owner, \"ERR_NOT_OWNER\");\n    _;\n  }\n\n  constructor(address owner) public {\n    _owner = owner;\n  }\n\n  function getOwner() external view returns (address) {\n    return _owner;\n  }\n\n  function setOwner(address owner) external _owner_ {\n    require(owner != address(0), \"ERR_NULL_ADDRESS\");\n    _owner = owner;\n    emit OwnerSet(owner);\n  }\n}"
    },
    "contracts/SaltyLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\nimport \"./ManyToOneImplementationHolder.sol\";\nimport {\n  DelegateCallProxyManyToOne\n} from \"./DelegateCallProxyManyToOne.sol\";\nimport {\n  DelegateCallProxyOneToOne\n} from \"./DelegateCallProxyOneToOne.sol\";\nimport { Create2 } from \"@openzeppelin/contracts/utils/Create2.sol\";\n\n\nlibrary SaltyLib {\n/* ---  Constants  --- */\n  bytes32 internal constant ONE_TO_ONE_CODEHASH = keccak256(\n    type(DelegateCallProxyOneToOne).creationCode\n  );\n\n  bytes32 internal constant MANY_TO_ONE_CODEHASH = keccak256(\n    type(DelegateCallProxyManyToOne).creationCode\n  );\n\n  bytes32 internal constant IMPLEMENTATION_HOLDER_CODEHASH = keccak256(\n    type(ManyToOneImplementationHolder).creationCode\n  );\n\n/* ---  Salt Derivation  --- */\n\n  /**\n   * @dev Derives the create2 salt for a many-to-one proxy.\n   *\n   * Many different contracts in the Indexed framework may use the\n   * same implementation contract, and they all use the same init\n   * code, so we derive the actual create2 salt from a combination\n   * of the implementation ID, the address of the account requesting\n   * deployment and the user-supplied salt.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deriveManyToOneSalt(\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (bytes32)\n  {\n    return keccak256(\n      abi.encodePacked(\n        originator,\n        implementationID,\n        suppliedSalt\n      )\n    );\n  }\n\n  /**\n   * @dev Derives the create2 salt for a one-to-one proxy.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deriveOneToOneSalt(\n    address originator,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(originator, suppliedSalt));\n  }\n\n/* ---  Address Derivation  --- */\n\n  /**\n   * @dev Computes the create2 address for a one-to-one proxy deployed\n   * by `deployer` (the factory) when requested by `originator` using\n   * `suppliedSalt`.\n   *\n   * @param deployer Address of the proxy factory.\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function computeProxyAddressOneToOne(\n    address deployer,\n    address originator,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 salt = deriveOneToOneSalt(originator, suppliedSalt);\n    return Create2.computeAddress(salt, ONE_TO_ONE_CODEHASH, deployer);\n  }\n\n  /**\n   * @dev Computes the create2 address for a many-to-one proxy for the\n   * implementation `implementationID` deployed by `deployer` (the factory)\n   * when requested by `originator` using `suppliedSalt`.\n   *\n   * @param deployer Address of the proxy factory.\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n  */\n  function computeProxyAddressManyToOne(\n    address deployer,\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 salt = deriveManyToOneSalt(\n      originator,\n      implementationID,\n      suppliedSalt\n    );\n    return Create2.computeAddress(salt, MANY_TO_ONE_CODEHASH, deployer);\n  }\n\n  /**\n   * @dev Computes the create2 address of the implementation holder\n   * for `implementationID`.\n   *\n   * @param deployer Address of the proxy factory.\n   * @param implementationID The identifier for the contract implementation.\n  */\n  function computeHolderAddressManyToOne(\n    address deployer,\n    bytes32 implementationID\n  )\n    internal\n    pure\n    returns (address)\n  {\n    return Create2.computeAddress(\n      implementationID,\n      IMPLEMENTATION_HOLDER_CODEHASH,\n      deployer\n    );\n  }\n}"
    },
    "contracts/mocks/ProxyTest.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport { DelegateCallProxyManager } from \"../DelegateCallProxyManager.sol\";\nimport { SaltyLib as Salty } from \"../SaltyLib.sol\";\nimport \"./TestOrder.sol\";\n\n\ncontract MockProxyLogic1 {\n  uint256 internal _value = 0;\n\n  function incrementValue() external {\n    _value += 1;\n  }\n\n  function decrementValue() external {\n    _value -= 1;\n  }\n\n  function getValue() external view returns (uint) {\n    return _value;\n  }\n}\n\n\ncontract MockProxyLogic2 {\n  uint256 internal _value = 0;\n\n  function incrementValue() external {\n    _value += 2;\n  }\n\n  function decrementValue() external {\n    _value -= 2;\n  }\n\n  function getValue() external view returns (uint) {\n    return _value;\n  }\n}\n\n\ncontract ApprovalTest {\n  bytes32 internal constant TEST_IMPLEMENTATION_ID = keccak256(\"ProxyLogic.sol\");\n  function deploy(DelegateCallProxyManager manager, bytes32 salt) external returns (address proxyAddress) {\n    return manager.deployProxyManyToOne(TEST_IMPLEMENTATION_ID, salt);\n  }\n}\n\n\ncontract ProxyTest is TestOrder {\n  bytes32 internal constant TEST_IMPLEMENTATION_ID = keccak256(\"ProxyLogic.sol\");\n  DelegateCallProxyManager public manager;\n  ApprovalTest internal _approvalTest;\n  MockProxyLogic1 implementation1;\n  MockProxyLogic2 implementation2;\n  address proxyAddressMT1;\n  address proxyAddress1T1;\n\n  constructor() public {\n    manager = new DelegateCallProxyManager();\n    _approvalTest = new ApprovalTest();\n    implementation1 = new MockProxyLogic1();\n    implementation2 = new MockProxyLogic2();\n  }\n\n  function test_deployInvalidImplementation() external testIndex(0) {\n    try manager.deployProxyManyToOne(TEST_IMPLEMENTATION_ID, keccak256(\"Salt1\")) {\n      revert(\"Expected error.\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_IMPLEMENTATION_ID\"),\n        \"Error: Expected ERR_IMPLEMENTATION_ID error message.\"\n      );\n    }\n  }\n\n  function test_createManyToOneProxyRelationship() external testIndex(1) {\n    manager.createManyToOneProxyRelationship(TEST_IMPLEMENTATION_ID, address(implementation1));\n    address implHolder = manager.getImplementationHolder(TEST_IMPLEMENTATION_ID);\n    require(\n      implHolder == manager.computeHolderAddressManyToOne(TEST_IMPLEMENTATION_ID),\n      \"Error: Unexpected implementation holder address\"\n    );\n    (bool success, bytes memory data) = implHolder.call(\"\");\n    require(success, \"Error: Failed to query implementation address.\");\n    require(\n      abi.decode((data), (address)) == address(implementation1),\n      \"Error: Implementation holder returned unexpected implementation address.\"\n    );\n  }\n\n  function test_unapprovedDeployer() external testIndex(2) {\n    try _approvalTest.deploy(manager, keccak256(\"Salt1\")) {\n      revert(\"Expected error\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_NOT_APPROVED\"),\n        \"Error: Expected ERR_NOT_APPROVED error message.\"\n      );\n    }\n  }\n\n  function test_approveDeployer() external testIndex(3) {\n    manager.approveDeployer(address(_approvalTest));\n    require(\n      manager.isApprovedDeployer(address(_approvalTest)),\n      \"Error: Deployer not approved.\"\n    );\n  }\n\n  function test_deployProxyManyToOne() external testIndex(4) {\n    address expectedAddress = Salty.computeProxyAddressManyToOne(\n      address(manager),\n      address(_approvalTest),\n      TEST_IMPLEMENTATION_ID,\n      keccak256(\"Salt1\")\n    );\n    proxyAddressMT1 = _approvalTest.deploy(manager, keccak256(\"Salt1\"));\n    require(\n      proxyAddressMT1 == expectedAddress,\n      \"Error: unexpected proxy address.\"\n    );\n    MockProxyLogic1 proxy = MockProxyLogic1(proxyAddressMT1);\n    require(proxy.getValue() == 0, \"Error: Expected proxy to return 0 for stored value.\");\n    proxy.incrementValue();\n    require(proxy.getValue() == 1, \"Error: Expected proxy to return 1 for stored value.\");\n    proxy.decrementValue();\n    require(proxy.getValue() == 0, \"Error: Expected proxy to return 0 for stored value.\");\n  }\n\n  function test_revokeDeployerApproval() external testIndex(5) {\n    manager.revokeDeployerApproval(address(_approvalTest));\n    try _approvalTest.deploy(manager, keccak256(\"Salt2\")) {\n      revert(\"Expected error\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_NOT_APPROVED\"),\n        \"Error: Expected ERR_NOT_APPROVED error message.\"\n      );\n    }\n  }\n\n  function test_setImplementationAddressManyToOne() external testIndex(6) {\n    manager.setImplementationAddressManyToOne(TEST_IMPLEMENTATION_ID, address(implementation2));\n    MockProxyLogic2 proxy = MockProxyLogic2(proxyAddressMT1);\n    require(proxy.getValue() == 0, \"Error: Expected proxy to return 0 for stored value.\");\n    proxy.incrementValue();\n    require(proxy.getValue() == 2, \"Error: Expected proxy to return 2 for stored value.\");\n    proxy.decrementValue();\n    require(proxy.getValue() == 0, \"Error: Expected proxy to return 0 for stored value.\");\n  }\n\n  function test_deployProxyOneToOne() external testIndex(7) {\n    proxyAddress1T1 = manager.deployProxyOneToOne(\n      keccak256(\"Salty\"), address(implementation1)\n    );\n    require(\n      proxyAddress1T1 == Salty.computeProxyAddressOneToOne(\n        address(manager),\n        address(this),\n        keccak256(\"Salty\")\n      ),\n      \"Error: Unexpected proxy address.\"\n    );\n    MockProxyLogic1 proxy = MockProxyLogic1(proxyAddress1T1);\n    require(proxy.getValue() == 0, \"Error: Expected proxy to return 0 for stored value.\");\n    proxy.incrementValue();\n    require(proxy.getValue() == 1, \"Error: Expected proxy to return 1 for stored value.\");\n    proxy.decrementValue();\n    require(proxy.getValue() == 0, \"Error: Expected proxy to return 0 for stored value.\");\n  }\n\n  function test_setImplementationAddressOneToOne() external testIndex(8) {\n    manager.setImplementationAddressOneToOne(\n      proxyAddress1T1, address(implementation2)\n    );\n    MockProxyLogic2 proxy = MockProxyLogic2(proxyAddress1T1);\n    require(proxy.getValue() == 0, \"Error: Expected proxy to return 0 for stored value.\");\n    proxy.incrementValue();\n    require(proxy.getValue() == 2, \"Error: Expected proxy to return 2 for stored value.\");\n    proxy.decrementValue();\n    require(proxy.getValue() == 0, \"Error: Expected proxy to return 0 for stored value.\");\n  }\n}"
    },
    "contracts/mocks/TestOrder.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ncontract TestOrder {\n  uint256 internal _testStep;\n  uint256 internal _timestampLast;\n\n  modifier testIndex(uint256 i) {\n    require(_testStep++ == i, \"Error: Wrong test order.\");\n    _;\n  }\n\n  modifier markTime {\n    _timestampLast = block.timestamp;\n    _;\n  }\n\n  modifier forceDelay(uint256 delay) {\n    require(block.timestamp - _timestampLast >= delay, \"Error: test requires time delay\");\n    _timestampLast = block.timestamp;\n    _;\n  }\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}